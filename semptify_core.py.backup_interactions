"""
SEMPTIFY CORE - Context Data Systemâ„¢
====================================

The heart of Semptify: A circular intelligence system where everything connects.

Context Ring Architecture:
    Documents â†” Users â†” Timeline â†” Case â†” Events â†” Context â†’ (back to Documents)

Every piece of data is a node in the ring. Each node connects to others,
creating a living system that learns and suggests next steps.

This is Semptify's core innovation: Not just storing data, but understanding
the CONTEXT and RELATIONSHIPS between everything.
"""

import json
import sqlite3
import hashlib
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import os

# ============================================================================
# ENUMS & CONSTANTS
# ============================================================================

class NodeType(Enum):
    DOCUMENT = "document"
    USER = "user"
    TIMELINE = "timeline"
    CASE = "case"
    EVENT = "event"
    CONTEXT = "context"

class DocumentType(Enum):
    LEASE = "lease"
    NOTICE = "notice"
    COURT_FILING = "court_filing"
    EVIDENCE = "evidence"
    COMMUNICATION = "communication"
    PAYMENT_RECORD = "payment_record"
    INSPECTION_REPORT = "inspection_report"
    OTHER = "other"

class LegalSignificance(Enum):
    CRITICAL = "critical"      # Must-have for case
    IMPORTANT = "important"    # Strengthens case significantly
    SUPPORTING = "supporting"  # Nice to have
    INFORMATIONAL = "informational"

class CaseStatus(Enum):
    ASSESSMENT = "assessment"
    PREPARING = "preparing"
    FILED = "filed"
    PENDING = "pending"
    RESOLVED = "resolved"

# ============================================================================
# DATA CLASSES (Nodes in the Ring)
# ============================================================================

@dataclass
class DocumentNode:
    """A document is more than a file - it's a context node"""
    id: str
    user_id: str
    filepath: str
    filename: str
    doc_type: str  # DocumentType
    upload_date: str
    size_bytes: int
    sha256: str
    
    # Context extraction
    extracted_dates: List[str] = None
    extracted_amounts: List[float] = None
    extracted_names: List[str] = None
    legal_significance: str = "informational"
    keywords: List[str] = None
    
    # Ring connections
    related_events: List[str] = None
    related_timeline_entries: List[str] = None
    case_id: Optional[str] = None
    
    # Intelligence
    auto_tags: List[str] = None
    suggestions: List[str] = None
    
    def __post_init__(self):
        if self.extracted_dates is None:
            self.extracted_dates = []
        if self.extracted_amounts is None:
            self.extracted_amounts = []
        if self.extracted_names is None:
            self.extracted_names = []
        if self.keywords is None:
            self.keywords = []
        if self.related_events is None:
            self.related_events = []
        if self.related_timeline_entries is None:
            self.related_timeline_entries = []
        if self.auto_tags is None:
            self.auto_tags = []
        if self.suggestions is None:
            self.suggestions = []

@dataclass
class UserNode:
    """User context - their situation, documents, timeline"""
    id: str
    created_at: str
    role: int  # 0=User, 1=Manager, 2=Advocate, 3=Attorney, 4=Admin, 5=Developer
    
    # Context
    document_count: int = 0
    case_status: str = "assessment"
    case_strength: float = 0.0
    next_steps: List[str] = None
    missing_documents: List[str] = None
    
    # Ring connections
    document_ids: List[str] = None
    timeline_ids: List[str] = None
    case_id: Optional[str] = None
    
    def __post_init__(self):
        if self.next_steps is None:
            self.next_steps = []
        if self.missing_documents is None:
            self.missing_documents = []
        if self.document_ids is None:
            self.document_ids = []
        if self.timeline_ids is None:
            self.timeline_ids = []

@dataclass
class TimelineNode:
    """Timeline entry - part of the user's story"""
    id: str
    user_id: str
    event_date: str
    title: str
    description: str
    event_type: str
    
    # Ring connections
    related_documents: List[str] = None
    related_events: List[str] = None
    
    # Intelligence
    legal_impact: str = "low"  # low, medium, high, critical
    
    def __post_init__(self):
        if self.related_documents is None:
            self.related_documents = []
        if self.related_events is None:
            self.related_events = []

@dataclass
class CaseNode:
    """The case itself - where everything connects"""
    id: str
    user_id: str
    status: str  # CaseStatus
    created_at: str
    
    # Case details
    case_type: str  # eviction_defense, habitability, discrimination, etc.
    jurisdiction: str
    
    # Ring connections
    document_ids: List[str] = None
    timeline_ids: List[str] = None
    event_ids: List[str] = None
    
    # Intelligence
    strength_score: float = 0.0
    missing_elements: List[str] = None
    recommendations: List[str] = None
    deadlines: List[Dict[str, str]] = None
    
    def __post_init__(self):
        if self.document_ids is None:
            self.document_ids = []
        if self.timeline_ids is None:
            self.timeline_ids = []
        if self.event_ids is None:
            self.event_ids = []
        if self.missing_elements is None:
            self.missing_elements = []
        if self.recommendations is None:
            self.recommendations = []
        if self.deadlines is None:
            self.deadlines = []

@dataclass
class EventNode:
    """Legal/case event - court dates, notice received, etc."""
    id: str
    user_id: str
    event_date: str
    event_type: str
    title: str
    description: str
    
    # Ring connections
    related_documents: List[str] = None
    timeline_id: Optional[str] = None
    case_id: Optional[str] = None
    
    # Intelligence
    requires_action: bool = False
    action_deadline: Optional[str] = None
    suggested_actions: List[str] = None
    
    def __post_init__(self):
        if self.related_documents is None:
            self.related_documents = []
        if self.suggested_actions is None:
            self.suggested_actions = []

@dataclass
class ContextData:
    """The complete context - the full ring assembled"""
    user: UserNode
    documents: List[DocumentNode]
    timeline: List[TimelineNode]
    case: Optional[CaseNode]
    events: List[EventNode]
    
    # Intelligence
    overall_strength: float = 0.0
    next_steps: List[str] = None
    urgent_actions: List[Dict[str, Any]] = None
    suggestions: List[str] = None
    
    def __post_init__(self):
        if self.next_steps is None:
            self.next_steps = []
        if self.urgent_actions is None:
            self.urgent_actions = []
        if self.suggestions is None:
            self.suggestions = []

# ============================================================================
# CONTEXT RING - The Core Intelligence Engine
# ============================================================================

class ContextRing:
    """
    The Context Data Systemâ„¢ - Circular Intelligence
    
    This is Semptify's core innovation. Instead of siloed data,
    everything connects in a ring where:
    
    1. Documents are analyzed and understood
    2. Users get intelligent suggestions
    3. Timeline builds their story
    4. Case data shows strength/gaps
    5. Events trigger actions
    6. Context flows back to improve everything
    
    The ring learns and adapts. Each interaction makes it smarter.
    """
    
    def __init__(self, db_path: str = "users.db"):
        self.db_path = db_path
        self.vault_base = Path("uploads/vault")
        
    def _get_conn(self) -> sqlite3.Connection:
        """Get database connection"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        return conn
    
    # ========================================================================
    # CORE RING OPERATION - Get Complete Context
    # ========================================================================
    
    def get_context(self, user_id: str) -> ContextData:
        """
        Get the complete Context Ring for a user.
        
        This is THE central function. All GUIs should call this
        instead of making direct database queries.
        
        Returns a ContextData object with all nodes connected.
        """
        conn = self._get_conn()
        try:
            # Build each node in the ring
            user = self._get_user_node(conn, user_id)
            documents = self._get_document_nodes(conn, user_id)
            timeline = self._get_timeline_nodes(conn, user_id)
            case = self._get_case_node(conn, user_id)
            events = self._get_event_nodes(conn, user_id)
            
            # Calculate intelligence
            overall_strength = self._calculate_overall_strength(
                user, documents, timeline, case, events
            )
            next_steps = self._generate_next_steps(
                user, documents, timeline, case, events
            )
            urgent_actions = self._find_urgent_actions(events, case)
            suggestions = self._generate_suggestions(
                user, documents, timeline, case
            )
            
            return ContextData(
                user=user,
                documents=documents,
                timeline=timeline,
                case=case,
                events=events,
                overall_strength=overall_strength,
                next_steps=next_steps,
                urgent_actions=urgent_actions,
                suggestions=suggestions
            )
        finally:
            conn.close()
    
    # ========================================================================
    # NODE BUILDERS - Construct each part of the ring
    # ========================================================================
    
    def _get_user_node(self, conn: sqlite3.Connection, user_id: str) -> UserNode:
        """Build user node with context"""
        cursor = conn.execute(
            "SELECT * FROM users WHERE id = ?", (user_id,)
        )
        row = cursor.fetchone()
        if not row:
            raise ValueError(f"User {user_id} not found")
        
        # Get document count
        doc_count = conn.execute(
            "SELECT COUNT(*) FROM documents WHERE user_id = ?", (user_id,)
        ).fetchone()[0] if self._table_exists(conn, "documents") else 0
        
        # Get role (default to 0 if no column yet)
        role = row["role"] if "role" in row.keys() else 0
        
        return UserNode(
            id=str(row["id"]),
            created_at=row["created_at"],
            role=role,
            document_count=doc_count,
            case_status="assessment",
            case_strength=0.0
        )
    
    def _get_document_nodes(self, conn: sqlite3.Connection, user_id: str) -> List[DocumentNode]:
        """Build document nodes from vault"""
        documents = []
        
        user_vault = self.vault_base / user_id
        if not user_vault.exists():
            return documents
        
        # Scan vault directory
        for doc_file in user_vault.glob("**/*"):
            if doc_file.is_file() and not doc_file.name.startswith("notary_"):
                # Check for certificate
                cert_pattern = f"notary_*_{doc_file.stem}.json"
                certs = list(doc_file.parent.glob(cert_pattern))
                
                doc_hash = self._calculate_file_hash(doc_file)
                doc_type = self._classify_document(doc_file.name)
                
                # Extract context if certificate exists
                extracted_dates, extracted_amounts, extracted_names = [], [], []
                if certs:
                    cert_data = json.loads(certs[0].read_text())
                    # TODO: Extract from certificate evidence
                
                documents.append(DocumentNode(
                    id=doc_hash,
                    user_id=user_id,
                    filepath=str(doc_file),
                    filename=doc_file.name,
                    doc_type=doc_type,
                    upload_date=datetime.fromtimestamp(doc_file.stat().st_mtime).isoformat(),
                    size_bytes=doc_file.stat().st_size,
                    sha256=doc_hash,
                    extracted_dates=extracted_dates,
                    extracted_amounts=extracted_amounts,
                    extracted_names=extracted_names
                ))
        
        return documents
    
    def _get_timeline_nodes(self, conn: sqlite3.Connection, user_id: str) -> List[TimelineNode]:
        """Build timeline nodes"""
        if not self._table_exists(conn, "timeline_events"):
            return []
        
        cursor = conn.execute(
            "SELECT * FROM timeline_events WHERE user_id = ? ORDER BY event_date DESC",
            (user_id,)
        )
        
        nodes = []
        for row in cursor.fetchall():
            nodes.append(TimelineNode(
                id=str(row["id"]),
                user_id=str(row["user_id"]),
                event_date=row["event_date"],
                title=row["title"],
                description=row["description"],
                event_type=row["event_type"]
            ))
        
        return nodes
    
    def _get_case_node(self, conn: sqlite3.Connection, user_id: str) -> Optional[CaseNode]:
        """Build case node if exists"""
        if not self._table_exists(conn, "cases"):
            return None
        
        cursor = conn.execute(
            "SELECT * FROM cases WHERE user_id = ? LIMIT 1", (user_id,)
        )
        row = cursor.fetchone()
        if not row:
            return None
        
        return CaseNode(
            id=str(row["id"]),
            user_id=str(row["user_id"]),
            status=row["status"],
            created_at=row["created_at"],
            case_type=row["case_type"] if "case_type" in row.keys() else "unknown",
            jurisdiction=row["jurisdiction"] if "jurisdiction" in row.keys() else "unknown"
        )
    
    def _get_event_nodes(self, conn: sqlite3.Connection, user_id: str) -> List[EventNode]:
        """Build event nodes"""
        if not self._table_exists(conn, "events"):
            return []
        
        cursor = conn.execute(
            "SELECT * FROM events WHERE user_id = ? ORDER BY event_date DESC",
            (user_id,)
        )
        
        nodes = []
        for row in cursor.fetchall():
            nodes.append(EventNode(
                id=str(row["id"]),
                user_id=str(row["user_id"]),
                event_date=row["event_date"],
                event_type=row["event_type"],
                title=row["title"],
                description=row["description"]
            ))
        
        return nodes
    
    # ========================================================================
    # INTELLIGENCE LAYER - The Learning Ring
    # ========================================================================
    
    def _calculate_overall_strength(
        self, 
        user: UserNode, 
        documents: List[DocumentNode], 
        timeline: List[TimelineNode], 
        case: Optional[CaseNode], 
        events: List[EventNode]
    ) -> float:
        """Calculate case strength based on all context"""
        score = 0.0
        
        # Documents add strength
        doc_types = {d.doc_type for d in documents}
        if "lease" in doc_types:
            score += 20
        if "notice" in doc_types:
            score += 15
        if "evidence" in doc_types:
            score += 25
        if "payment_record" in doc_types:
            score += 20
        if "communication" in doc_types:
            score += 10
        
        # Timeline adds strength
        if len(timeline) >= 5:
            score += 10
        elif len(timeline) >= 3:
            score += 5
        
        # Critical events add strength
        for event in events:
            if "notice" in event.event_type.lower():
                score += 5
        
        return min(100.0, score)
    
    def _generate_next_steps(
        self,
        user: UserNode,
        documents: List[DocumentNode],
        timeline: List[TimelineNode],
        case: Optional[CaseNode],
        events: List[EventNode]
    ) -> List[str]:
        """Generate intelligent next steps based on context"""
        steps = []
        
        # Check for missing critical documents
        doc_types = {d.doc_type for d in documents}
        if "lease" not in doc_types:
            steps.append("ðŸ“„ Upload your lease agreement (critical for case)")
        if "notice" not in doc_types:
            steps.append("ï¿½ï¿½ Upload any notices received from landlord")
        if "evidence" not in doc_types and len(documents) > 0:
            steps.append("ðŸ“¸ Upload photos/videos as evidence")
        
        # Timeline guidance
        if len(timeline) < 3:
            steps.append("ðŸ“… Add more timeline entries - build your story")
        
        # Case progression
        if not case:
            steps.append("âš–ï¸ Complete qualification to assess your case")
        elif case.status == "assessment":
            steps.append("ðŸ“‹ Review assessment results and decide next action")
        
        return steps[:5]  # Top 5 most important
    
    def _find_urgent_actions(
        self, 
        events: List[EventNode], 
        case: Optional[CaseNode]
    ) -> List[Dict[str, Any]]:
        """Find time-sensitive actions"""
        urgent = []
        
        for event in events:
            if event.requires_action and event.action_deadline:
                deadline = datetime.fromisoformat(event.action_deadline)
                days_until = (deadline - datetime.now()).days
                
                if days_until <= 7:
                    urgent.append({
                        "event": event.title,
                        "deadline": event.action_deadline,
                        "days_remaining": days_until,
                        "actions": event.suggested_actions,
                        "urgency": "critical" if days_until <= 3 else "high"
                    })
        
        return sorted(urgent, key=lambda x: x["days_remaining"])
    
    def _generate_suggestions(
        self,
        user: UserNode,
        documents: List[DocumentNode],
        timeline: List[TimelineNode],
        case: Optional[CaseNode]
    ) -> List[str]:
        """Generate intelligent suggestions"""
        suggestions = []
        
        # Document organization
        if len(documents) > 5:
            suggestions.append("Consider organizing documents by type for easier access")
        
        # Timeline completeness
        if timeline:
            earliest = min(datetime.fromisoformat(t.event_date) for t in timeline)
            latest = max(datetime.fromisoformat(t.event_date) for t in timeline)
            span_days = (latest - earliest).days
            
            if span_days > 30 and len(timeline) < 5:
                suggestions.append("Your timeline spans several months - consider adding more detail")
        
        # Case strength
        if user.case_strength < 40:
            suggestions.append("Case strength is low - focus on gathering evidence")
        elif user.case_strength > 70:
            suggestions.append("Strong case! Consider consulting with an advocate")
        
        return suggestions
    
    # ========================================================================
    # DOCUMENT OPERATIONS - Ring Anchor
    # ========================================================================
    
    def add_document(
        self, 
        user_id: str, 
        filepath: str, 
        filename: str, 
        doc_type: Optional[str] = None
    ) -> DocumentNode:
        """Add document to the ring - triggers context update"""
        doc_hash = self._calculate_file_hash(Path(filepath))
        
        if not doc_type:
            doc_type = self._classify_document(filename)
        
        doc_node = DocumentNode(
            id=doc_hash,
            user_id=user_id,
            filepath=filepath,
            filename=filename,
            doc_type=doc_type,
            upload_date=datetime.now().isoformat(),
            size_bytes=Path(filepath).stat().st_size,
            sha256=doc_hash
        )
        
        # TODO: Trigger intelligence update
        # self._update_ring_intelligence(user_id)
        
        return doc_node
    
    def search_documents(
        self, 
        user_id: str, 
        query: str, 
        doc_type: Optional[str] = None
    ) -> List[DocumentNode]:
        """Search documents with context"""
        context = self.get_context(user_id)
        
        results = []
        query_lower = query.lower()
        
        for doc in context.documents:
            # Match filename
            if query_lower in doc.filename.lower():
                results.append(doc)
                continue
            
            # Match type
            if doc_type and doc.doc_type == doc_type:
                results.append(doc)
                continue
            
            # Match keywords
            if any(query_lower in kw.lower() for kw in doc.keywords):
                results.append(doc)
        
        return results
    
    # ========================================================================
    # UTILITIES
    # ========================================================================
    
    def _table_exists(self, conn: sqlite3.Connection, table_name: str) -> bool:
        """Check if table exists"""
        cursor = conn.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
            (table_name,)
        )
        return cursor.fetchone() is not None
    
    def _calculate_file_hash(self, filepath: Path) -> str:
        """Calculate SHA256 hash of file"""
        sha256_hash = hashlib.sha256()
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    
    def _classify_document(self, filename: str) -> str:
        """Basic document type classification"""
        filename_lower = filename.lower()
        
        if any(word in filename_lower for word in ["lease", "rental", "agreement"]):
            return "lease"
        elif any(word in filename_lower for word in ["notice", "eviction", "termination"]):
            return "notice"
        elif any(word in filename_lower for word in ["court", "filing", "complaint"]):
            return "court_filing"
        elif any(word in filename_lower for word in ["photo", "picture", "video", "image"]):
            return "evidence"
        elif any(word in filename_lower for word in ["email", "text", "message", "letter"]):
            return "communication"
        elif any(word in filename_lower for word in ["receipt", "payment", "bank", "check"]):
            return "payment_record"
        elif any(word in filename_lower for word in ["inspection", "report"]):
            return "inspection_report"
        else:
            return "other"

# ============================================================================
# CONVENIENCE FUNCTIONS - Easy Access to the Ring
# ============================================================================

def get_context(user_id: str) -> ContextData:
    """
    Get complete context for a user.
    
    This is what ALL GUIs should call instead of direct database queries.
    
    Usage:
        from semptify_core import get_context
        
        context = get_context(user_id)
        print(f"User has {len(context.documents)} documents")
        print(f"Case strength: {context.overall_strength}%")
        for step in context.next_steps:
            print(f"Next: {step}")
    """
    ring = ContextRing()
    return ring.get_context(user_id)

def add_document(user_id: str, filepath: str, filename: str) -> DocumentNode:
    """Add document to user's context ring"""
    ring = ContextRing()
    return ring.add_document(user_id, filepath, filename)

def search_documents(user_id: str, query: str) -> List[DocumentNode]:
    """Search user's documents"""
    ring = ContextRing()
    return ring.search_documents(user_id, query)

# ============================================================================
# MAIN - Testing/Demo
# ============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("  ðŸŽ¯ CONTEXT DATA SYSTEMâ„¢ - Core Engine")
    print("=" * 70)
    print()
    print("This is Semptify's core innovation:")
    print("Circular intelligence where everything connects.")
    print()
    print("Ready to power all 5 GUIs with unified context!")
    print()
